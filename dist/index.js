var W=Object.defineProperty;var V=(s,e,r)=>e in s?W(s,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[e]=r;var f=(s,e,r)=>(V(s,typeof e!="symbol"?e+"":e,r),r);import{Collection as g,FSAdapter as d}from"@prsm/arc";import{CommandServer as F}from"@prsm/duplex";import{EventEmitter as L}from"node:events";import h from"node:crypto";import{derToJose as _,joseToDer as j}from"ecdsa-sig-formatter";var H=["HS256","HS384","HS512","RS256","RS384","RS512"];function N(s){return H.includes(s)}var B={HS256:b(256),HS384:b(384),HS512:b(512),RS256:k(256),RS384:k(384),RS512:k(512),ES256:Q(256)};function b(s){function e(n,t){return h.createHmac(`sha${s}`,t).update(n).digest("base64")}function r(n,t,o){return e(n,o)===t}return{sign:e,verify:r}}function k(s){let e=`RSA-SHA${s}`;function r(t,o){return h.createSign(e).update(t).sign(o.toString(),"base64")}function n(t,o,a){let i=h.createVerify(e);return i.update(t),i.verify(a,o,"base64")}return{sign:r,verify:n}}function Q(s){let e=`RSA-SHA${s}`;function r(t,o){let a=h.createSign(e).update(t).sign({key:o.toString()},"base64");return _(a,`ES${s}`)}function n(t,o,a){o=j(o,`ES${s}`).toString("base64");let i=h.createVerify(e);return i.update(t),i.verify(a,o,"base64")}return{sign:r,verify:n}}function O(s){let e=JSON.stringify(s);return P(Buffer.from(e).toString("base64"))}function $(s){let e=Buffer.from(v(s),"base64").toString("utf-8");return JSON.parse(e)}function P(s){return s.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function v(s){s=s.toString();let e=4-s.length%4;if(e!==4)for(let r=0;r<e;r++)s+="=";return s.replace(/-/g,"+").replace(/_/g,"/")}function E(s,e,r="HS256"){if(!N(r))throw new Error(`${r} is an invalid algorithm type. Must be one of ${H}`);let n=O({alg:r,type:"JWT"}),t=O(s),o=`${n}.${t}`,a=B[r],i=P(a.sign(o,e));return`${o}.${i}`}function D(s){let e=s.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let r=$(e[0]),n=$(e[1]),t=Buffer.from(v(e[2]),"base64");return{header:r,payload:n,signature:t}}function m(s,e,r={}){let n=D(s),{payload:t}=n,o=s.split("."),a=r.alg??n.header.alg,i=Date.now(),c=B[a],u={decoded:n};return(r.sig===void 0||r.sig===!0)&&(u.sig=c.verify(`${o[0]}.${o[1]}`,v(o[2]),e)),t.exp!==void 0&&(u.exp=t.exp<i),t.nbf!==void 0&&(u.nbf=i>=t.nbf),r.iat!==void 0&&(u.iat=t.iat===r.iat),r.iss!==void 0&&(u.iss=t.iss===r.iss),r.jti!==void 0&&(u.jti=t.jti!==r.jti),r.sub!==void 0&&(u.sub=t.sub===r.sub),r.aud!==void 0&&(u.aud=t.aud===r.aud),u}var p=s=>{let e;try{e=m(s,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(r){return{valid:!1,reason:`Failed to parse token: ${r.message}`}}return e.sig?e.exp?{valid:!1,reason:"Token expired"}:{valid:!0}:{valid:!1,reason:"Invalid signature"}},q=s=>parseInt(s,10),S=s=>{let e={iat:Date.now(),exp:Date.now()+q(process.env.ACCESS_TOKEN_LIFETIME||"3600"),sub:s,permissions:{}};return E(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")},C=s=>{let e={iat:Date.now(),exp:Date.now()+q(process.env.REFRESH_TOKEN_LIFETIME||"86400"),sub:s};return E(e,process.env.REFRESH_TOKEN_SECRET||"SECRET")};import J from"crypto";var x=class{algorithm;saltLength;constructor(e="sha256",r=64){this.algorithm=e,this.saltLength=r}verify(e,r){let{algorithm:n,salt:t}=this.parse(e);return this.hash(r,n,t)===e}encode(e){let r=J.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,r)}hash(e,r,n){let t=J.createHash(r);return t.update(e),t.update(n,"utf8"),`${r}:${n}:${t.digest("base64")}`}parse(e){let r=e.split(":");if(r.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${r.length}`);let n=r[0],t=r[1],o=r[2];return{algorithm:n,salt:t,digest:o}}},T=new x;var y=class{static init({host:e="localhost",port:r=3351,secure:n=!1}){this.emitter=new L,this.queryHandler=new A,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,r,n)}static initializeCollections(){this.auth.users=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","users")}),this.auth.accessTokens=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","accessTokens")}),this.auth.refreshTokens=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","refreshTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:T.encode("root")})}static query(e){return this.queryHandler.query(e)}static createUser(e,r){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:T.encode(r)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,r,n){this.duplex=new F({host:e,port:r,secure:!1}),this.duplex.command(0,async(t,o)=>{if(this.emitter.emit("auth",{payload:t,connection:o}),!t.username||!t.password)return{error:"Invalid username or password"};let a=this.auth.users.find({username:t.username})[0];if(!a)return{error:"Invalid username or password"};if(!T.verify(a.password,t.password))return{error:"Invalid username or password"};let i=S(t.username),c=C(t.username);return this.auth.refreshTokens.remove({username:t.username}),this.auth.refreshTokens.insert({username:t.username,accessToken:i,refreshToken:c}),this.auth.accessTokens.remove({username:t.username}),this.auth.accessTokens.insert({username:t.username,accessToken:i}),{accessToken:i,refreshToken:c}}),this.duplex.command(1,async(t,o)=>{this.emitter.emit("refresh",{payload:t,connection:o});let{accessToken:a,refreshToken:i}=t;if(!a||!i)return{error:"Invalid access token or refresh token"};let c=this.auth.refreshTokens.find({refreshToken:i})[0];if(!c)return{error:"Invalid refresh token"};if(c.accessToken!==a)return{error:"Refresh token access token mismatch"};if(!m(i,process.env.REFRESH_TOKEN_SECRET).sig)return{error:"Invalid refresh token"};let w=S(c.username),I=C(c.username);return this.auth.refreshTokens.remove({username:c.username}),this.auth.refreshTokens.insert({username:c.username,accessToken:w,refreshToken:I}),this.auth.accessTokens.remove({username:c.username}),this.auth.accessTokens.insert({username:c.username,accessToken:w}),{accessToken:w,refreshToken:I}}),this.duplex.command(2,async(t,o)=>{this.emitter.emit("query",{payload:t,connection:o});let{collection:a,operation:i,data:c,accessToken:u}=t;return p(u).valid?this.queryHandler.query(t):{error:"Invalid access token"}}),this.duplex.command(3,async(t,o)=>{this.emitter.emit("createUser",{payload:t,connection:o});let{username:a,password:i,accessToken:c}=t;if(!a||!i)return{error:"Invalid username or password"};if(!p(c).valid)return{error:"Invalid access token"};try{return y.createUser(a,i),{success:!0}}catch(u){return{error:u.message}}}),this.duplex.command(4,async(t,o)=>{this.emitter.emit("removeUser",{payload:t,connection:o});let{username:a,password:i,accessToken:c}=t;if(!a||!i)return{error:"Invalid username or password"};if(!p(c).valid)return{error:"Invalid access token"};try{return y.removeUser(a),{success:!0}}catch(u){return{error:u.message}}})}},l=y;f(l,"queryHandler"),f(l,"duplex"),f(l,"auth",{}),f(l,"emitter");var U={autosync:!0,timestamps:!0},R=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let r={...U,adapter:new d(".data",e)};this.collections[e]={collection:new g(r),options:r}}return this.collections[e].collection}createCollectionWithOptions(e,r={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let n={...U,...r,adapter:new d(".data",e)};return this.collections[e]={collection:new g(n),options:n},this.collections[e].collection}},A=class{cm;constructor(){this.cm=new R}query(e){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let r=this.cm.getOrCreateCollection(e.collection);if(!r)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let n=e?.data?.query||{},t=e?.data?.operations||{},o=e?.data?.options||{};switch(e.operation){case"drop":return r.drop();case"find":return r.find(n,o);case"insert":return r.insert(n);case"update":return r.update(n,t,o);case"remove":return r.remove(n,o);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};export{l as ArcServer};
