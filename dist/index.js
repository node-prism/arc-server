var W=Object.defineProperty;var V=(n,e,r)=>e in n?W(n,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):n[e]=r;var h=(n,e,r)=>(V(n,typeof e!="symbol"?e+"":e,r),r);import{Collection as g,FSAdapter as d}from"@prsm/arc";import{CommandServer as L}from"@prsm/duplex";import f from"node:crypto";import{derToJose as _,joseToDer as j}from"ecdsa-sig-formatter";var H=["HS256","HS384","HS512","RS256","RS384","RS512"];function N(n){return H.includes(n)}var B={HS256:b(256),HS384:b(384),HS512:b(512),RS256:k(256),RS384:k(384),RS512:k(512),ES256:D(256)};function b(n){function e(s,t){return f.createHmac(`sha${n}`,t).update(s).digest("base64")}function r(s,t,o){return e(s,o)===t}return{sign:e,verify:r}}function k(n){let e=`RSA-SHA${n}`;function r(t,o){return f.createSign(e).update(t).sign(o.toString(),"base64")}function s(t,o,i){let a=f.createVerify(e);return a.update(t),a.verify(i,o,"base64")}return{sign:r,verify:s}}function D(n){let e=`RSA-SHA${n}`;function r(t,o){let i=f.createSign(e).update(t).sign({key:o.toString()},"base64");return _(i,`ES${n}`)}function s(t,o,i){o=j(o,`ES${n}`).toString("base64");let a=f.createVerify(e);return a.update(t),a.verify(i,o,"base64")}return{sign:r,verify:s}}function O(n){let e=JSON.stringify(n);return J(Buffer.from(e).toString("base64"))}function $(n){let e=Buffer.from(v(n),"base64").toString("utf-8");return JSON.parse(e)}function J(n){return n.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function v(n){n=n.toString();let e=4-n.length%4;if(e!==4)for(let r=0;r<e;r++)n+="=";return n.replace(/-/g,"+").replace(/_/g,"/")}function E(n,e,r="HS256"){if(!N(r))throw new Error(`${r} is an invalid algorithm type. Must be one of ${H}`);let s=O({alg:r,type:"JWT"}),t=O(n),o=`${s}.${t}`,i=B[r],a=J(i.sign(o,e));return`${o}.${a}`}function F(n){let e=n.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let r=$(e[0]),s=$(e[1]),t=Buffer.from(v(e[2]),"base64");return{header:r,payload:s,signature:t}}function m(n,e,r={}){let s=F(n),{payload:t}=s,o=n.split("."),i=r.alg??s.header.alg,a=Date.now(),c=B[i],u={decoded:s};return(r.sig===void 0||r.sig===!0)&&(u.sig=c.verify(`${o[0]}.${o[1]}`,v(o[2]),e)),t.exp!==void 0&&(u.exp=t.exp<a),t.nbf!==void 0&&(u.nbf=a>=t.nbf),r.iat!==void 0&&(u.iat=t.iat===r.iat),r.iss!==void 0&&(u.iss=t.iss===r.iss),r.jti!==void 0&&(u.jti=t.jti!==r.jti),r.sub!==void 0&&(u.sub=t.sub===r.sub),r.aud!==void 0&&(u.aud=t.aud===r.aud),u}var p=n=>{let e;try{e=m(n,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(r){return{valid:!1,reason:`Failed to parse token: ${r.message}`}}return e.sig?e.exp?{valid:!1,reason:"Token expired"}:{valid:!0}:{valid:!1,reason:"Invalid signature"}},P=n=>parseInt(n,10),S=n=>{let e={iat:Date.now(),exp:Date.now()+P(process.env.ACCESS_TOKEN_LIFETIME||"3600"),sub:n,permissions:{}};return E(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")},C=n=>{let e={iat:Date.now(),exp:Date.now()+P(process.env.REFRESH_TOKEN_LIFETIME||"86400"),sub:n};return E(e,process.env.REFRESH_TOKEN_SECRET||"SECRET")};import U from"crypto";var x=class{algorithm;saltLength;constructor(e="sha256",r=64){this.algorithm=e,this.saltLength=r}verify(e,r){let{algorithm:s,salt:t}=this.parse(e);return this.hash(r,s,t)===e}encode(e){let r=U.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,r)}hash(e,r,s){let t=U.createHash(r);return t.update(e),t.update(s,"utf8"),`${r}:${s}:${t.digest("base64")}`}parse(e){let r=e.split(":");if(r.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${r.length}`);let s=r[0],t=r[1],o=r[2];return{algorithm:s,salt:t,digest:o}}},T=new x;var y=class{static init({host:e="localhost",port:r=3351,secure:s=!1}){this.queryHandler=new A,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,r,s)}static initializeCollections(){this.auth.users=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","users")}),this.auth.accessTokens=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","accessTokens")}),this.auth.refreshTokens=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","refreshTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:T.encode("root")})}static createUser(e,r){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:T.encode(r)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,r,s){this.duplex=new L({host:e,port:r,secure:!1}),this.duplex.command(0,async(t,o)=>{if(!t.username||!t.password)return{error:"Invalid username or password"};let i=this.auth.users.find({username:t.username})[0];if(!i)return{error:"Invalid username or password"};if(!T.verify(i.password,t.password))return{error:"Invalid username or password"};let a=S(t.username),c=C(t.username);return this.auth.refreshTokens.remove({username:t.username}),this.auth.refreshTokens.insert({username:t.username,accessToken:a,refreshToken:c}),this.auth.accessTokens.remove({username:t.username}),this.auth.accessTokens.insert({username:t.username,accessToken:a}),{accessToken:a,refreshToken:c}}),this.duplex.command(1,async(t,o)=>{let{accessToken:i,refreshToken:a}=t;if(!i||!a)return{error:"Invalid access token or refresh token"};let c=this.auth.refreshTokens.find({refreshToken:a})[0];if(!c)return{error:"Invalid refresh token"};if(c.accessToken!==i)return{error:"Refresh token access token mismatch"};if(!m(a,process.env.REFRESH_TOKEN_SECRET).sig)return{error:"Invalid refresh token"};let w=S(c.username),I=C(c.username);return this.auth.refreshTokens.remove({username:c.username}),this.auth.refreshTokens.insert({username:c.username,accessToken:w,refreshToken:I}),this.auth.accessTokens.remove({username:c.username}),this.auth.accessTokens.insert({username:c.username,accessToken:w}),{accessToken:w,refreshToken:I}}),this.duplex.command(2,async(t,o)=>{let{collection:i,operation:a,data:c,accessToken:u}=t;return p(u).valid?this.queryHandler.query(t,o):{error:"Invalid access token"}}),this.duplex.command(3,async(t,o)=>{let{username:i,password:a,accessToken:c}=t;if(!i||!a)return{error:"Invalid username or password"};if(!p(c).valid)return{error:"Invalid access token"};try{return y.createUser(i,a),{success:!0}}catch(u){return{error:u.message}}}),this.duplex.command(4,async(t,o)=>{let{username:i,password:a,accessToken:c}=t;if(!i||!a)return{error:"Invalid username or password"};if(!p(c).valid)return{error:"Invalid access token"};try{return y.removeUser(i),{success:!0}}catch(u){return{error:u.message}}})}},l=y;h(l,"queryHandler"),h(l,"duplex"),h(l,"auth",{});var q={autosync:!0,timestamps:!0},R=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let r={...q,adapter:new d(".data",e)};this.collections[e]={collection:new g(r),options:r}}return this.collections[e].collection}createCollectionWithOptions(e,r={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let s={...q,...r,adapter:new d(".data",e)};return this.collections[e]={collection:new g(s),options:s},this.collections[e].collection}},A=class{cm;constructor(){this.cm=new R}query(e,r){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let s=this.cm.getOrCreateCollection(e.collection);if(!s)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let t=e?.data?.query||{},o=e?.data?.operations||{},i=e?.data?.options||{};switch(e.operation){case"drop":return s.drop();case"find":return s.find(t,i);case"insert":return s.insert(t);case"update":return s.update(t,o,i);case"remove":return s.remove(t,i);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};export{l as ArcServer};
