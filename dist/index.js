var q=Object.defineProperty;var J=(s,e,t)=>e in s?q(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var d=(s,e,t)=>(J(s,typeof e!="symbol"?e+"":e,t),t);import{Collection as m,FSAdapter as h,ShardedCollection as D}from"@prsm/arc";import{CommandServer as Q}from"@prsm/duplex";import{EventEmitter as N}from"node:events";import g from"node:crypto";import{derToJose as U,joseToDer as I}from"ecdsa-sig-formatter";var A=["HS256","HS384","HS512","RS256","RS384","RS512"];function W(s){return A.includes(s)}var O={HS256:w(256),HS384:w(384),HS512:w(512),RS256:b(256),RS384:b(384),RS512:b(512),ES256:V(256)};function w(s){function e(n,r){return g.createHmac(`sha${s}`,r).update(n).digest("base64")}function t(n,r,i){return e(n,i)===r}return{sign:e,verify:t}}function b(s){let e=`RSA-SHA${s}`;function t(r,i){return g.createSign(e).update(r).sign(i.toString(),"base64")}function n(r,i,o){let a=g.createVerify(e);return a.update(r),a.verify(o,i,"base64")}return{sign:t,verify:n}}function V(s){let e=`RSA-SHA${s}`;function t(r,i){let o=g.createSign(e).update(r).sign({key:i.toString()},"base64");return U(o,`ES${s}`)}function n(r,i,o){i=I(i,`ES${s}`).toString("base64");let a=g.createVerify(e);return a.update(r),a.verify(o,i,"base64")}return{sign:t,verify:n}}function E(s){let e=JSON.stringify(s);return P(Buffer.from(e).toString("base64"))}function x(s){let e=Buffer.from(S(s),"base64").toString("utf-8");return JSON.parse(e)}function P(s){return s.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function S(s){s=s.toString();let e=4-s.length%4;if(e!==4)for(let t=0;t<e;t++)s+="=";return s.replace(/-/g,"+").replace(/_/g,"/")}function $(s,e,t="HS256"){if(!W(t))throw new Error(`${t} is an invalid algorithm type. Must be one of ${A}`);let n=E({alg:t,type:"JWT"}),r=E(s),i=`${n}.${r}`,o=O[t],a=P(o.sign(i,e));return`${i}.${a}`}function j(s){let e=s.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let t=x(e[0]),n=x(e[1]),r=Buffer.from(S(e[2]),"base64");return{header:t,payload:n,signature:r}}function R(s,e,t={}){let n=j(s),{payload:r}=n,i=s.split("."),o=t.alg??n.header.alg,a=Date.now(),l=O[o],c={decoded:n};return(t.sig===void 0||t.sig===!0)&&(c.sig=l.verify(`${i[0]}.${i[1]}`,S(i[2]),e)),r.exp!==void 0&&(c.exp=r.exp<a),r.nbf!==void 0&&(c.nbf=a>=r.nbf),t.iat!==void 0&&(c.iat=r.iat===t.iat),t.iss!==void 0&&(c.iss=r.iss===t.iss),t.jti!==void 0&&(c.jti=r.jti!==t.jti),t.sub!==void 0&&(c.sub=r.sub===t.sub),t.aud!==void 0&&(c.aud=r.aud===t.aud),c}var f=s=>{let e;try{e=R(s,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(t){return{valid:!1,reason:`Failed to parse token: ${t.message}`}}return e.sig?{valid:!0}:{valid:!1,reason:"Invalid signature"}},B=s=>{let e={iat:Date.now(),sub:s,permissions:{}};return $(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")};import H from"crypto";var v=class{algorithm;saltLength;constructor(e="sha256",t=64){this.algorithm=e,this.saltLength=t}verify(e,t){let{algorithm:n,salt:r}=this.parse(e);return this.hash(t,n,r)===e}encode(e){let t=H.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,t)}hash(e,t,n){let r=H.createHash(t);return r.update(e),r.update(n,"utf8"),`${t}:${n}:${r.digest("base64")}`}parse(e){let t=e.split(":");if(t.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${t.length}`);let n=t[0],r=t[1],i=t[2];return{algorithm:n,salt:r,digest:i}}},p=new v;var y=class{static async init({host:e="localhost",port:t=3351,secure:n=!1,shardedCollections:r=[]}){this.emitter=new N,this.queryHandler=new k(r),this.initializeCollections(),this.ensureRootUserExists(),await this.createServer(e,t,n)}static initializeCollections(){this.auth.users=new m({autosync:!0,timestamps:!0,adapter:new h({storagePath:".internal",name:"users"})}),this.auth.accessTokens=new m({autosync:!0,timestamps:!0,adapter:new h({storagePath:".internal",name:"accessTokens"})})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:p.encode("root")})}static query(e){return this.queryHandler.query(e)}static createUser(e,t){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:p.encode(t)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static async createServer(e,t,n=!1){this.duplex=new Q({host:e,port:t,secure:n}),await this.duplex.connect(),this.duplex.command(0,async(r,i)=>{if(this.emitter.emit("auth",{payload:r,connection:i}),!r.username||!r.password)return{error:"Invalid username or password"};let o=this.auth.users.find({username:r.username})[0];if(!o)return{error:"Invalid username or password"};if(!p.verify(o.password,r.password))return{error:"Invalid username or password"};let a=B(r.username);return this.auth.accessTokens.remove({username:r.username}),this.auth.accessTokens.insert({username:r.username,accessToken:a}),{accessToken:a}}),this.duplex.command(2,async(r,i)=>{this.emitter.emit("query",{payload:r,connection:i});let{accessToken:o}=r;return f(o).valid?this.queryHandler.query(r):{error:"Invalid access token"}}),this.duplex.command(3,async(r,i)=>{this.emitter.emit("createUser",{payload:r,connection:i});let{username:o,password:a,accessToken:l}=r;if(!o||!a)return{error:"Invalid username or password"};if(!f(l).valid)return{error:"Invalid access token"};try{return y.createUser(o,a),{success:!0}}catch(c){return{error:c.message}}}),this.duplex.command(4,async(r,i)=>{this.emitter.emit("removeUser",{payload:r,connection:i});let{username:o,password:a,accessToken:l}=r;if(!o||!a)return{error:"Invalid username or password"};if(!f(l).valid)return{error:"Invalid access token"};try{return y.removeUser(o),{success:!0}}catch(c){return{error:c.message}}})}},u=y;d(u,"queryHandler"),d(u,"duplex"),d(u,"auth",{}),d(u,"emitter");var C={autosync:!0,timestamps:!0},T=class{shardedCollections=[];collections={};constructor(e=[]){this.shardedCollections=e}getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let t=this.shardedCollections.find(n=>n.name===e);if(t){let n={...C,adapter:new h({storagePath:".data",name:e})},r={...t,adapterOptions:{...t.adapterOptions,storagePath:".data",name:e}};this.collections[e]={collection:new D(n,r),options:n}}else{let n={...C,adapter:new h({storagePath:".data",name:e})};this.collections[e]={collection:new m(n),options:n}}}return this.collections[e].collection}createCollectionWithOptions(e,t={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let n={...C,...t,adapter:new h({storagePath:".data",name:e})};return this.collections[e]={collection:new m(n),options:n},this.collections[e].collection}},k=class{cm;constructor(e=[]){this.cm=new T(e)}query(e){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let t=this.cm.getOrCreateCollection(e.collection);if(!t)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let n=e?.data?.query||{},r=e?.data?.operations||{},i=e?.data?.options||{};switch(e.operation){case"drop":return t.drop();case"find":return t.find(n,i);case"insert":return t.insert(n);case"update":return t.update(n,r,i);case"remove":return t.remove(n,i);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};export{u as ArcServer};
