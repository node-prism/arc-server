var W=Object.defineProperty;var V=(s,e,r)=>e in s?W(s,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[e]=r;var f=(s,e,r)=>(V(s,typeof e!="symbol"?e+"":e,r),r);import{Collection as g,FSAdapter as d}from"@prsm/arc";import{CommandServer as L}from"@prsm/duplex";import{EventEmitter as K}from"node:stream";import h from"node:crypto";import{derToJose as _,joseToDer as j}from"ecdsa-sig-formatter";var H=["HS256","HS384","HS512","RS256","RS384","RS512"];function N(s){return H.includes(s)}var B={HS256:k(256),HS384:k(384),HS512:k(512),RS256:v(256),RS384:v(384),RS512:v(512),ES256:D(256)};function k(s){function e(n,t){return h.createHmac(`sha${s}`,t).update(n).digest("base64")}function r(n,t,o){return e(n,o)===t}return{sign:e,verify:r}}function v(s){let e=`RSA-SHA${s}`;function r(t,o){return h.createSign(e).update(t).sign(o.toString(),"base64")}function n(t,o,i){let a=h.createVerify(e);return a.update(t),a.verify(i,o,"base64")}return{sign:r,verify:n}}function D(s){let e=`RSA-SHA${s}`;function r(t,o){let i=h.createSign(e).update(t).sign({key:o.toString()},"base64");return _(i,`ES${s}`)}function n(t,o,i){o=j(o,`ES${s}`).toString("base64");let a=h.createVerify(e);return a.update(t),a.verify(i,o,"base64")}return{sign:r,verify:n}}function O(s){let e=JSON.stringify(s);return J(Buffer.from(e).toString("base64"))}function $(s){let e=Buffer.from(y(s),"base64").toString("utf-8");return JSON.parse(e)}function J(s){return s.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function y(s){s=s.toString();let e=4-s.length%4;if(e!==4)for(let r=0;r<e;r++)s+="=";return s.replace(/-/g,"+").replace(/_/g,"/")}function E(s,e,r="HS256"){if(!N(r))throw new Error(`${r} is an invalid algorithm type. Must be one of ${H}`);let n=O({alg:r,type:"JWT"}),t=O(s),o=`${n}.${t}`,i=B[r],a=J(i.sign(o,e));return`${o}.${a}`}function F(s){let e=s.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let r=$(e[0]),n=$(e[1]),t=Buffer.from(y(e[2]),"base64");return{header:r,payload:n,signature:t}}function m(s,e,r={}){let n=F(s),{payload:t}=n,o=s.split("."),i=r.alg??n.header.alg,a=Date.now(),c=B[i],u={decoded:n};return(r.sig===void 0||r.sig===!0)&&(u.sig=c.verify(`${o[0]}.${o[1]}`,y(o[2]),e)),t.exp!==void 0&&(u.exp=t.exp<a),t.nbf!==void 0&&(u.nbf=a>=t.nbf),r.iat!==void 0&&(u.iat=t.iat===r.iat),r.iss!==void 0&&(u.iss=t.iss===r.iss),r.jti!==void 0&&(u.jti=t.jti!==r.jti),r.sub!==void 0&&(u.sub=t.sub===r.sub),r.aud!==void 0&&(u.aud=t.aud===r.aud),u}var p=s=>{let e;try{e=m(s,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(r){return{valid:!1,reason:`Failed to parse token: ${r.message}`}}return e.sig?e.exp?{valid:!1,reason:"Token expired"}:{valid:!0}:{valid:!1,reason:"Invalid signature"}},U=s=>parseInt(s,10),S=s=>{let e={iat:Date.now(),exp:Date.now()+U(process.env.ACCESS_TOKEN_LIFETIME||"3600"),sub:s,permissions:{}};return E(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")},C=s=>{let e={iat:Date.now(),exp:Date.now()+U(process.env.REFRESH_TOKEN_LIFETIME||"86400"),sub:s};return E(e,process.env.REFRESH_TOKEN_SECRET||"SECRET")};import P from"crypto";var x=class{algorithm;saltLength;constructor(e="sha256",r=64){this.algorithm=e,this.saltLength=r}verify(e,r){let{algorithm:n,salt:t}=this.parse(e);return this.hash(r,n,t)===e}encode(e){let r=P.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,r)}hash(e,r,n){let t=P.createHash(r);return t.update(e),t.update(n,"utf8"),`${r}:${n}:${t.digest("base64")}`}parse(e){let r=e.split(":");if(r.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${r.length}`);let n=r[0],t=r[1],o=r[2];return{algorithm:n,salt:t,digest:o}}},T=new x;var w=class{static init({host:e="localhost",port:r=3351,secure:n=!1}){this.emitter=new K,this.queryHandler=new A,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,r,n)}static initializeCollections(){this.auth.users=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","users")}),this.auth.accessTokens=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","accessTokens")}),this.auth.refreshTokens=new g({autosync:!0,timestamps:!0,adapter:new d(".internal","refreshTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:T.encode("root")})}static createUser(e,r){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:T.encode(r)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,r,n){this.duplex=new L({host:e,port:r,secure:!1}),this.duplex.command(0,async(t,o)=>{if(this.emitter.emit("auth",{payload:t,connection:o}),!t.username||!t.password)return{error:"Invalid username or password"};let i=this.auth.users.find({username:t.username})[0];if(!i)return{error:"Invalid username or password"};if(!T.verify(i.password,t.password))return{error:"Invalid username or password"};let a=S(t.username),c=C(t.username);return this.auth.refreshTokens.remove({username:t.username}),this.auth.refreshTokens.insert({username:t.username,accessToken:a,refreshToken:c}),this.auth.accessTokens.remove({username:t.username}),this.auth.accessTokens.insert({username:t.username,accessToken:a}),{accessToken:a,refreshToken:c}}),this.duplex.command(1,async(t,o)=>{this.emitter.emit("refresh",{payload:t,connection:o});let{accessToken:i,refreshToken:a}=t;if(!i||!a)return{error:"Invalid access token or refresh token"};let c=this.auth.refreshTokens.find({refreshToken:a})[0];if(!c)return{error:"Invalid refresh token"};if(c.accessToken!==i)return{error:"Refresh token access token mismatch"};if(!m(a,process.env.REFRESH_TOKEN_SECRET).sig)return{error:"Invalid refresh token"};let b=S(c.username),I=C(c.username);return this.auth.refreshTokens.remove({username:c.username}),this.auth.refreshTokens.insert({username:c.username,accessToken:b,refreshToken:I}),this.auth.accessTokens.remove({username:c.username}),this.auth.accessTokens.insert({username:c.username,accessToken:b}),{accessToken:b,refreshToken:I}}),this.duplex.command(2,async(t,o)=>{this.emitter.emit("query",{payload:t,connection:o});let{collection:i,operation:a,data:c,accessToken:u}=t;return p(u).valid?this.queryHandler.query(t,o):{error:"Invalid access token"}}),this.duplex.command(3,async(t,o)=>{this.emitter.emit("createUser",{payload:t,connection:o});let{username:i,password:a,accessToken:c}=t;if(!i||!a)return{error:"Invalid username or password"};if(!p(c).valid)return{error:"Invalid access token"};try{return w.createUser(i,a),{success:!0}}catch(u){return{error:u.message}}}),this.duplex.command(4,async(t,o)=>{this.emitter.emit("removeUser",{payload:t,connection:o});let{username:i,password:a,accessToken:c}=t;if(!i||!a)return{error:"Invalid username or password"};if(!p(c).valid)return{error:"Invalid access token"};try{return w.removeUser(i),{success:!0}}catch(u){return{error:u.message}}})}},l=w;f(l,"queryHandler"),f(l,"duplex"),f(l,"auth",{}),f(l,"emitter");var q={autosync:!0,timestamps:!0},R=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let r={...q,adapter:new d(".data",e)};this.collections[e]={collection:new g(r),options:r}}return this.collections[e].collection}createCollectionWithOptions(e,r={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let n={...q,...r,adapter:new d(".data",e)};return this.collections[e]={collection:new g(n),options:n},this.collections[e].collection}},A=class{cm;constructor(){this.cm=new R}query(e,r){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let n=this.cm.getOrCreateCollection(e.collection);if(!n)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let t=e?.data?.query||{},o=e?.data?.operations||{},i=e?.data?.options||{};switch(e.operation){case"drop":return n.drop();case"find":return n.find(t,i);case"insert":return n.insert(t);case"update":return n.update(t,o,i);case"remove":return n.remove(t,i);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};export{l as ArcServer};
