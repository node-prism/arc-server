var J=Object.defineProperty;var U=(r,e,t)=>e in r?J(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var d=(r,e,t)=>(U(r,typeof e!="symbol"?e+"":e,t),t);import{Collection as m,FSAdapter as p}from"@prsm/arc";import{CommandServer as Q}from"@prsm/duplex";import{EventEmitter as N}from"node:events";import g from"node:crypto";import{derToJose as I,joseToDer as P}from"ecdsa-sig-formatter";var k=["HS256","HS384","HS512","RS256","RS384","RS512"];function W(r){return k.includes(r)}var A={HS256:b(256),HS384:b(384),HS512:b(512),RS256:w(256),RS384:w(384),RS512:w(512),ES256:V(256)};function b(r){function e(s,n){return g.createHmac(`sha${r}`,n).update(s).digest("base64")}function t(s,n,o){return e(s,o)===n}return{sign:e,verify:t}}function w(r){let e=`RSA-SHA${r}`;function t(n,o){return g.createSign(e).update(n).sign(o.toString(),"base64")}function s(n,o,i){let a=g.createVerify(e);return a.update(n),a.verify(i,o,"base64")}return{sign:t,verify:s}}function V(r){let e=`RSA-SHA${r}`;function t(n,o){let i=g.createSign(e).update(n).sign({key:o.toString()},"base64");return I(i,`ES${r}`)}function s(n,o,i){o=P(o,`ES${r}`).toString("base64");let a=g.createVerify(e);return a.update(n),a.verify(i,o,"base64")}return{sign:t,verify:s}}function T(r){let e=JSON.stringify(r);return $(Buffer.from(e).toString("base64"))}function E(r){let e=Buffer.from(v(r),"base64").toString("utf-8");return JSON.parse(e)}function $(r){return r.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function v(r){r=r.toString();let e=4-r.length%4;if(e!==4)for(let t=0;t<e;t++)r+="=";return r.replace(/-/g,"+").replace(/_/g,"/")}function R(r,e,t="HS256"){if(!W(t))throw new Error(`${t} is an invalid algorithm type. Must be one of ${k}`);let s=T({alg:t,type:"JWT"}),n=T(r),o=`${s}.${n}`,i=A[t],a=$(i.sign(o,e));return`${o}.${a}`}function j(r){let e=r.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let t=E(e[0]),s=E(e[1]),n=Buffer.from(v(e[2]),"base64");return{header:t,payload:s,signature:n}}function q(r,e,t={}){let s=j(r),{payload:n}=s,o=r.split("."),i=t.alg??s.header.alg,a=Date.now(),l=A[i],u={decoded:s};return(t.sig===void 0||t.sig===!0)&&(u.sig=l.verify(`${o[0]}.${o[1]}`,v(o[2]),e)),n.exp!==void 0&&(u.exp=n.exp<a),n.nbf!==void 0&&(u.nbf=a>=n.nbf),t.iat!==void 0&&(u.iat=n.iat===t.iat),t.iss!==void 0&&(u.iss=n.iss===t.iss),t.jti!==void 0&&(u.jti=n.jti!==t.jti),t.sub!==void 0&&(u.sub=n.sub===t.sub),t.aud!==void 0&&(u.aud=n.aud===t.aud),u}var f=r=>{let e;try{e=q(r,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(t){return{valid:!1,reason:`Failed to parse token: ${t.message}`}}return e.sig?{valid:!0}:{valid:!1,reason:"Invalid signature"}};var B=r=>{let e={iat:Date.now(),sub:r,permissions:{}};return R(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")};import O from"crypto";var S=class{algorithm;saltLength;constructor(e="sha256",t=64){this.algorithm=e,this.saltLength=t}verify(e,t){let{algorithm:s,salt:n}=this.parse(e);return this.hash(t,s,n)===e}encode(e){let t=O.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,t)}hash(e,t,s){let n=O.createHash(t);return n.update(e),n.update(s,"utf8"),`${t}:${s}:${n.digest("base64")}`}parse(e){let t=e.split(":");if(t.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${t.length}`);let s=t[0],n=t[1],o=t[2];return{algorithm:s,salt:n,digest:o}}},h=new S;var y=class{static init({host:e="localhost",port:t=3351,secure:s=!1}){this.emitter=new N,this.queryHandler=new x,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,t,s)}static initializeCollections(){this.auth.users=new m({autosync:!0,timestamps:!0,adapter:new p(".internal","users")}),this.auth.accessTokens=new m({autosync:!0,timestamps:!0,adapter:new p(".internal","accessTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:h.encode("root")})}static query(e){return this.queryHandler.query(e)}static createUser(e,t){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:h.encode(t)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,t,s=!1){this.duplex=new Q({host:e,port:t,secure:s}),this.duplex.command(0,async(n,o)=>{if(this.emitter.emit("auth",{payload:n,connection:o}),!n.username||!n.password)return{error:"Invalid username or password"};let i=this.auth.users.find({username:n.username})[0];if(!i)return{error:"Invalid username or password"};if(!h.verify(i.password,n.password))return{error:"Invalid username or password"};let a=B(n.username);return this.auth.accessTokens.remove({username:n.username}),this.auth.accessTokens.insert({username:n.username,accessToken:a}),{accessToken:a}}),this.duplex.command(2,async(n,o)=>{this.emitter.emit("query",{payload:n,connection:o});let{accessToken:i}=n;return f(i).valid?this.queryHandler.query(n):{error:"Invalid access token"}}),this.duplex.command(3,async(n,o)=>{this.emitter.emit("createUser",{payload:n,connection:o});let{username:i,password:a,accessToken:l}=n;if(!i||!a)return{error:"Invalid username or password"};if(!f(l).valid)return{error:"Invalid access token"};try{return y.createUser(i,a),{success:!0}}catch(u){return{error:u.message}}}),this.duplex.command(4,async(n,o)=>{this.emitter.emit("removeUser",{payload:n,connection:o});let{username:i,password:a,accessToken:l}=n;if(!i||!a)return{error:"Invalid username or password"};if(!f(l).valid)return{error:"Invalid access token"};try{return y.removeUser(i),{success:!0}}catch(u){return{error:u.message}}})}},c=y;d(c,"queryHandler"),d(c,"duplex"),d(c,"auth",{}),d(c,"emitter");var H={autosync:!0,timestamps:!0},C=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let t={...H,adapter:new p(".data",e)};this.collections[e]={collection:new m(t),options:t}}return this.collections[e].collection}createCollectionWithOptions(e,t={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let s={...H,...t,adapter:new p(".data",e)};return this.collections[e]={collection:new m(s),options:s},this.collections[e].collection}},x=class{cm;constructor(){this.cm=new C}query(e){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let t=this.cm.getOrCreateCollection(e.collection);if(!t)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let s=e?.data?.query||{},n=e?.data?.operations||{},o=e?.data?.options||{};switch(e.operation){case"drop":return t.drop();case"find":return t.find(s,o);case"insert":return t.insert(s);case"update":return t.update(s,n,o);case"remove":return t.remove(s,o);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};c.init({host:"0.0.0.0",port:3351,secure:!1});c.duplex.on("insecureConnection",r=>{console.log("insecureConnection from",r.remoteAddress)});c.duplex.on("secureConnection",r=>{console.log("secureConnection from",r.remoteAddress)});c.duplex.on("error",r=>{console.log("error:",r)});c.duplex.on("remoteClose",r=>{console.log("remoteClose:",r)});c.duplex.on("close",r=>{console.log("close:",r)});c.duplex.on("closed",r=>{console.log("closed:",r)});c.duplex.on("disconnect",r=>{console.log("disconnect:",r)});c.emitter.on("auth",({payload:r})=>{console.log("auth:",r)});c.emitter.on("query",({payload:r})=>{console.log("query:",r)});export{c as ArcServer};
