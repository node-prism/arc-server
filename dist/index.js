var J=Object.defineProperty;var U=(n,e,t)=>e in n?J(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var g=(n,e,t)=>(U(n,typeof e!="symbol"?e+"":e,t),t);import{Collection as m,FSAdapter as p}from"@prsm/arc";import{CommandServer as Q}from"@prsm/duplex";import{EventEmitter as N}from"node:events";import d from"node:crypto";import{derToJose as P,joseToDer as I}from"ecdsa-sig-formatter";var k=["HS256","HS384","HS512","RS256","RS384","RS512"];function W(n){return k.includes(n)}var A={HS256:b(256),HS384:b(384),HS512:b(512),RS256:w(256),RS384:w(384),RS512:w(512),ES256:V(256)};function b(n){function e(s,r){return d.createHmac(`sha${n}`,r).update(s).digest("base64")}function t(s,r,i){return e(s,i)===r}return{sign:e,verify:t}}function w(n){let e=`RSA-SHA${n}`;function t(r,i){return d.createSign(e).update(r).sign(i.toString(),"base64")}function s(r,i,o){let a=d.createVerify(e);return a.update(r),a.verify(o,i,"base64")}return{sign:t,verify:s}}function V(n){let e=`RSA-SHA${n}`;function t(r,i){let o=d.createSign(e).update(r).sign({key:i.toString()},"base64");return P(o,`ES${n}`)}function s(r,i,o){i=I(i,`ES${n}`).toString("base64");let a=d.createVerify(e);return a.update(r),a.verify(o,i,"base64")}return{sign:t,verify:s}}function E(n){let e=JSON.stringify(n);return $(Buffer.from(e).toString("base64"))}function x(n){let e=Buffer.from(v(n),"base64").toString("utf-8");return JSON.parse(e)}function $(n){return n.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function v(n){n=n.toString();let e=4-n.length%4;if(e!==4)for(let t=0;t<e;t++)n+="=";return n.replace(/-/g,"+").replace(/_/g,"/")}function R(n,e,t="HS256"){if(!W(t))throw new Error(`${t} is an invalid algorithm type. Must be one of ${k}`);let s=E({alg:t,type:"JWT"}),r=E(n),i=`${s}.${r}`,o=A[t],a=$(o.sign(i,e));return`${i}.${a}`}function j(n){let e=n.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let t=x(e[0]),s=x(e[1]),r=Buffer.from(v(e[2]),"base64");return{header:t,payload:s,signature:r}}function B(n,e,t={}){let s=j(n),{payload:r}=s,i=n.split("."),o=t.alg??s.header.alg,a=Date.now(),l=A[o],c={decoded:s};return(t.sig===void 0||t.sig===!0)&&(c.sig=l.verify(`${i[0]}.${i[1]}`,v(i[2]),e)),r.exp!==void 0&&(c.exp=r.exp<a),r.nbf!==void 0&&(c.nbf=a>=r.nbf),t.iat!==void 0&&(c.iat=r.iat===t.iat),t.iss!==void 0&&(c.iss=r.iss===t.iss),t.jti!==void 0&&(c.jti=r.jti!==t.jti),t.sub!==void 0&&(c.sub=r.sub===t.sub),t.aud!==void 0&&(c.aud=r.aud===t.aud),c}var f=n=>{let e;try{e=B(n,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(t){return{valid:!1,reason:`Failed to parse token: ${t.message}`}}return e.sig?{valid:!0}:{valid:!1,reason:"Invalid signature"}},O=n=>{let e={iat:Date.now(),sub:n,permissions:{}};return R(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")};import H from"crypto";var S=class{algorithm;saltLength;constructor(e="sha256",t=64){this.algorithm=e,this.saltLength=t}verify(e,t){let{algorithm:s,salt:r}=this.parse(e);return this.hash(t,s,r)===e}encode(e){let t=H.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,t)}hash(e,t,s){let r=H.createHash(t);return r.update(e),r.update(s,"utf8"),`${t}:${s}:${r.digest("base64")}`}parse(e){let t=e.split(":");if(t.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${t.length}`);let s=t[0],r=t[1],i=t[2];return{algorithm:s,salt:r,digest:i}}},h=new S;var y=class{static init({host:e="localhost",port:t=3351,secure:s=!1}){this.emitter=new N,this.queryHandler=new C,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,t,s)}static initializeCollections(){this.auth.users=new m({autosync:!0,timestamps:!0,adapter:new p(".internal","users")}),this.auth.accessTokens=new m({autosync:!0,timestamps:!0,adapter:new p(".internal","accessTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:h.encode("root")})}static query(e){return this.queryHandler.query(e)}static createUser(e,t){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:h.encode(t)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,t,s=!1){this.duplex=new Q({host:e,port:t,secure:s}),this.duplex.command(0,async(r,i)=>{if(this.emitter.emit("auth",{payload:r,connection:i}),!r.username||!r.password)return{error:"Invalid username or password"};let o=this.auth.users.find({username:r.username})[0];if(!o)return{error:"Invalid username or password"};if(!h.verify(o.password,r.password))return{error:"Invalid username or password"};let a=O(r.username);return this.auth.accessTokens.remove({username:r.username}),this.auth.accessTokens.insert({username:r.username,accessToken:a}),{accessToken:a}}),this.duplex.command(2,async(r,i)=>{this.emitter.emit("query",{payload:r,connection:i});let{accessToken:o}=r;return f(o).valid?this.queryHandler.query(r):{error:"Invalid access token"}}),this.duplex.command(3,async(r,i)=>{this.emitter.emit("createUser",{payload:r,connection:i});let{username:o,password:a,accessToken:l}=r;if(!o||!a)return{error:"Invalid username or password"};if(!f(l).valid)return{error:"Invalid access token"};try{return y.createUser(o,a),{success:!0}}catch(c){return{error:c.message}}}),this.duplex.command(4,async(r,i)=>{this.emitter.emit("removeUser",{payload:r,connection:i});let{username:o,password:a,accessToken:l}=r;if(!o||!a)return{error:"Invalid username or password"};if(!f(l).valid)return{error:"Invalid access token"};try{return y.removeUser(o),{success:!0}}catch(c){return{error:c.message}}})}},u=y;g(u,"queryHandler"),g(u,"duplex"),g(u,"auth",{}),g(u,"emitter");var q={autosync:!0,timestamps:!0},T=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let t={...q,adapter:new p(".data",e)};this.collections[e]={collection:new m(t),options:t}}return this.collections[e].collection}createCollectionWithOptions(e,t={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let s={...q,...t,adapter:new p(".data",e)};return this.collections[e]={collection:new m(s),options:s},this.collections[e].collection}},C=class{cm;constructor(){this.cm=new T}query(e){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let t=this.cm.getOrCreateCollection(e.collection);if(!t)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let s=e?.data?.query||{},r=e?.data?.operations||{},i=e?.data?.options||{};switch(e.operation){case"drop":return t.drop();case"find":return t.find(s,i);case"insert":return t.insert(s);case"update":return t.update(s,r,i);case"remove":return t.remove(s,i);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};export{u as ArcServer};
