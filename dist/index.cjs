var D=Object.create;var g=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames;var K=Object.getPrototypeOf,Q=Object.prototype.hasOwnProperty;var M=(s,e,r)=>e in s?g(s,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[e]=r;var z=(s,e)=>{for(var r in e)g(s,r,{get:e[r],enumerable:!0})},H=(s,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let t of L(e))!Q.call(s,t)&&t!==r&&g(s,t,{get:()=>e[t],enumerable:!(n=F(e,t))||n.enumerable});return s};var B=(s,e,r)=>(r=s!=null?D(K(s)):{},H(e||!s||!s.__esModule?g(r,"default",{value:s,enumerable:!0}):r,s)),G=s=>H(g({},"__esModule",{value:!0}),s);var d=(s,e,r)=>(M(s,typeof e!="symbol"?e+"":e,r),r);var ee={};z(ee,{ArcServer:()=>f});module.exports=G(ee);var l=require("@prsm/arc"),j=require("@prsm/duplex"),N=require("events");var h=B(require("crypto"),1),m=require("ecdsa-sig-formatter"),P=["HS256","HS384","HS512","RS256","RS384","RS512"];function X(s){return P.includes(s)}var q={HS256:v(256),HS384:v(384),HS512:v(512),RS256:y(256),RS384:y(384),RS512:y(512),ES256:Y(256)};function v(s){function e(n,t){return h.default.createHmac(`sha${s}`,t).update(n).digest("base64")}function r(n,t,o){return e(n,o)===t}return{sign:e,verify:r}}function y(s){let e=`RSA-SHA${s}`;function r(t,o){return h.default.createSign(e).update(t).sign(o.toString(),"base64")}function n(t,o,i){let a=h.default.createVerify(e);return a.update(t),a.verify(i,o,"base64")}return{sign:r,verify:n}}function Y(s){let e=`RSA-SHA${s}`;function r(t,o){let i=h.default.createSign(e).update(t).sign({key:o.toString()},"base64");return(0,m.derToJose)(i,`ES${s}`)}function n(t,o,i){o=(0,m.joseToDer)(o,`ES${s}`).toString("base64");let a=h.default.createVerify(e);return a.update(t),a.verify(i,o,"base64")}return{sign:r,verify:n}}function J(s){let e=JSON.stringify(s);return W(Buffer.from(e).toString("base64"))}function U(s){let e=Buffer.from(E(s),"base64").toString("utf-8");return JSON.parse(e)}function W(s){return s.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function E(s){s=s.toString();let e=4-s.length%4;if(e!==4)for(let r=0;r<e;r++)s+="=";return s.replace(/-/g,"+").replace(/_/g,"/")}function S(s,e,r="HS256"){if(!X(r))throw new Error(`${r} is an invalid algorithm type. Must be one of ${P}`);let n=J({alg:r,type:"JWT"}),t=J(s),o=`${n}.${t}`,i=q[r],a=W(i.sign(o,e));return`${o}.${a}`}function Z(s){let e=s.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let r=U(e[0]),n=U(e[1]),t=Buffer.from(E(e[2]),"base64");return{header:r,payload:n,signature:t}}function p(s,e,r={}){let n=Z(s),{payload:t}=n,o=s.split("."),i=r.alg??n.header.alg,a=Date.now(),c=q[i],u={decoded:n};return(r.sig===void 0||r.sig===!0)&&(u.sig=c.verify(`${o[0]}.${o[1]}`,E(o[2]),e)),t.exp!==void 0&&(u.exp=t.exp<a),t.nbf!==void 0&&(u.nbf=a>=t.nbf),r.iat!==void 0&&(u.iat=t.iat===r.iat),r.iss!==void 0&&(u.iss=t.iss===r.iss),r.jti!==void 0&&(u.jti=t.jti!==r.jti),r.sub!==void 0&&(u.sub=t.sub===r.sub),r.aud!==void 0&&(u.aud=t.aud===r.aud),u}var T=s=>{let e;try{e=p(s,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(r){return{valid:!1,reason:`Failed to parse token: ${r.message}`}}return e.sig?e.exp?{valid:!1,reason:"Token expired"}:{valid:!0}:{valid:!1,reason:"Invalid signature"}},V=s=>parseInt(s,10),C=s=>{let e={iat:Date.now(),exp:Date.now()+V(process.env.ACCESS_TOKEN_LIFETIME||"3600"),sub:s,permissions:{}};return S(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")},x=s=>{let e={iat:Date.now(),exp:Date.now()+V(process.env.REFRESH_TOKEN_LIFETIME||"86400"),sub:s};return S(e,process.env.REFRESH_TOKEN_SECRET||"SECRET")};var R=B(require("crypto"),1),A=class{algorithm;saltLength;constructor(e="sha256",r=64){this.algorithm=e,this.saltLength=r}verify(e,r){let{algorithm:n,salt:t}=this.parse(e);return this.hash(r,n,t)===e}encode(e){let r=R.default.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,r)}hash(e,r,n){let t=R.default.createHash(r);return t.update(e),t.update(n,"utf8"),`${r}:${n}:${t.digest("base64")}`}parse(e){let r=e.split(":");if(r.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${r.length}`);let n=r[0],t=r[1],o=r[2];return{algorithm:n,salt:t,digest:o}}},w=new A;var b=class{static init({host:e="localhost",port:r=3351,secure:n=!1}){this.emitter=new N.EventEmitter,this.queryHandler=new O,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,r,n)}static initializeCollections(){this.auth.users=new l.Collection({autosync:!0,timestamps:!0,adapter:new l.FSAdapter(".internal","users")}),this.auth.accessTokens=new l.Collection({autosync:!0,timestamps:!0,adapter:new l.FSAdapter(".internal","accessTokens")}),this.auth.refreshTokens=new l.Collection({autosync:!0,timestamps:!0,adapter:new l.FSAdapter(".internal","refreshTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:w.encode("root")})}static createUser(e,r){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:w.encode(r)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,r,n){this.duplex=new j.CommandServer({host:e,port:r,secure:!1}),this.duplex.command(0,async(t,o)=>{if(this.emitter.emit("auth",{payload:t,connection:o}),!t.username||!t.password)return{error:"Invalid username or password"};let i=this.auth.users.find({username:t.username})[0];if(!i)return{error:"Invalid username or password"};if(!w.verify(i.password,t.password))return{error:"Invalid username or password"};let a=C(t.username),c=x(t.username);return this.auth.refreshTokens.remove({username:t.username}),this.auth.refreshTokens.insert({username:t.username,accessToken:a,refreshToken:c}),this.auth.accessTokens.remove({username:t.username}),this.auth.accessTokens.insert({username:t.username,accessToken:a}),{accessToken:a,refreshToken:c}}),this.duplex.command(1,async(t,o)=>{this.emitter.emit("refresh",{payload:t,connection:o});let{accessToken:i,refreshToken:a}=t;if(!i||!a)return{error:"Invalid access token or refresh token"};let c=this.auth.refreshTokens.find({refreshToken:a})[0];if(!c)return{error:"Invalid refresh token"};if(c.accessToken!==i)return{error:"Refresh token access token mismatch"};if(!p(a,process.env.REFRESH_TOKEN_SECRET).sig)return{error:"Invalid refresh token"};let k=C(c.username),$=x(c.username);return this.auth.refreshTokens.remove({username:c.username}),this.auth.refreshTokens.insert({username:c.username,accessToken:k,refreshToken:$}),this.auth.accessTokens.remove({username:c.username}),this.auth.accessTokens.insert({username:c.username,accessToken:k}),{accessToken:k,refreshToken:$}}),this.duplex.command(2,async(t,o)=>{this.emitter.emit("query",{payload:t,connection:o});let{collection:i,operation:a,data:c,accessToken:u}=t;return T(u).valid?this.queryHandler.query(t,o):{error:"Invalid access token"}}),this.duplex.command(3,async(t,o)=>{this.emitter.emit("createUser",{payload:t,connection:o});let{username:i,password:a,accessToken:c}=t;if(!i||!a)return{error:"Invalid username or password"};if(!T(c).valid)return{error:"Invalid access token"};try{return b.createUser(i,a),{success:!0}}catch(u){return{error:u.message}}}),this.duplex.command(4,async(t,o)=>{this.emitter.emit("removeUser",{payload:t,connection:o});let{username:i,password:a,accessToken:c}=t;if(!i||!a)return{error:"Invalid username or password"};if(!T(c).valid)return{error:"Invalid access token"};try{return b.removeUser(i),{success:!0}}catch(u){return{error:u.message}}})}},f=b;d(f,"queryHandler"),d(f,"duplex"),d(f,"auth",{}),d(f,"emitter");var _={autosync:!0,timestamps:!0},I=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let r={..._,adapter:new l.FSAdapter(".data",e)};this.collections[e]={collection:new l.Collection(r),options:r}}return this.collections[e].collection}createCollectionWithOptions(e,r={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let n={..._,...r,adapter:new l.FSAdapter(".data",e)};return this.collections[e]={collection:new l.Collection(n),options:n},this.collections[e].collection}},O=class{cm;constructor(){this.cm=new I}query(e,r){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let n=this.cm.getOrCreateCollection(e.collection);if(!n)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let t=e?.data?.query||{},o=e?.data?.operations||{},i=e?.data?.options||{};switch(e.operation){case"drop":return n.drop();case"find":return n.find(t,i);case"insert":return n.insert(t);case"update":return n.update(t,o,i);case"remove":return n.remove(t,i);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};0&&(module.exports={ArcServer});
