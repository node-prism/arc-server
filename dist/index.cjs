var V=Object.create;var f=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var Q=Object.getOwnPropertyNames;var N=Object.getPrototypeOf,L=Object.prototype.hasOwnProperty;var D=(r,e,t)=>e in r?f(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var _=(r,e)=>{for(var t in e)f(r,t,{get:e[t],enumerable:!0})},k=(r,e,t,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Q(e))!L.call(r,n)&&n!==t&&f(r,n,{get:()=>e[n],enumerable:!(s=j(e,n))||s.enumerable});return r};var A=(r,e,t)=>(t=r!=null?V(N(r)):{},k(e||!r||!r.__esModule?f(t,"default",{value:r,enumerable:!0}):t,r)),z=r=>k(f({},"__esModule",{value:!0}),r);var h=(r,e,t)=>(D(r,typeof e!="symbol"?e+"":e,t),t);var G={};_(G,{ArcServer:()=>c});module.exports=z(G);var l=require("@prsm/arc"),P=require("@prsm/duplex"),W=require("events");var d=A(require("crypto"),1),m=require("ecdsa-sig-formatter"),q=["HS256","HS384","HS512","RS256","RS384","RS512"];function F(r){return q.includes(r)}var B={HS256:w(256),HS384:w(384),HS512:w(512),RS256:v(256),RS384:v(384),RS512:v(512),ES256:K(256)};function w(r){function e(s,n){return d.default.createHmac(`sha${r}`,n).update(s).digest("base64")}function t(s,n,o){return e(s,o)===n}return{sign:e,verify:t}}function v(r){let e=`RSA-SHA${r}`;function t(n,o){return d.default.createSign(e).update(n).sign(o.toString(),"base64")}function s(n,o,i){let a=d.default.createVerify(e);return a.update(n),a.verify(i,o,"base64")}return{sign:t,verify:s}}function K(r){let e=`RSA-SHA${r}`;function t(n,o){let i=d.default.createSign(e).update(n).sign({key:o.toString()},"base64");return(0,m.derToJose)(i,`ES${r}`)}function s(n,o,i){o=(0,m.joseToDer)(o,`ES${r}`).toString("base64");let a=d.default.createVerify(e);return a.update(n),a.verify(i,o,"base64")}return{sign:t,verify:s}}function $(r){let e=JSON.stringify(r);return O(Buffer.from(e).toString("base64"))}function R(r){let e=Buffer.from(S(r),"base64").toString("utf-8");return JSON.parse(e)}function O(r){return r.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function S(r){r=r.toString();let e=4-r.length%4;if(e!==4)for(let t=0;t<e;t++)r+="=";return r.replace(/-/g,"+").replace(/_/g,"/")}function H(r,e,t="HS256"){if(!F(t))throw new Error(`${t} is an invalid algorithm type. Must be one of ${q}`);let s=$({alg:t,type:"JWT"}),n=$(r),o=`${s}.${n}`,i=B[t],a=O(i.sign(o,e));return`${o}.${a}`}function M(r){let e=r.split(".");if(e.length!==3)throw new Error(`Decode expected 3 parts to encoded token, got ${e.length}`);let t=R(e[0]),s=R(e[1]),n=Buffer.from(S(e[2]),"base64");return{header:t,payload:s,signature:n}}function J(r,e,t={}){let s=M(r),{payload:n}=s,o=r.split("."),i=t.alg??s.header.alg,a=Date.now(),g=B[i],u={decoded:s};return(t.sig===void 0||t.sig===!0)&&(u.sig=g.verify(`${o[0]}.${o[1]}`,S(o[2]),e)),n.exp!==void 0&&(u.exp=n.exp<a),n.nbf!==void 0&&(u.nbf=a>=n.nbf),t.iat!==void 0&&(u.iat=n.iat===t.iat),t.iss!==void 0&&(u.iss=n.iss===t.iss),t.jti!==void 0&&(u.jti=n.jti!==t.jti),t.sub!==void 0&&(u.sub=n.sub===t.sub),t.aud!==void 0&&(u.aud=n.aud===t.aud),u}var p=r=>{let e;try{e=J(r,process.env.ACCESS_TOKEN_SECRET||"SECRET")}catch(t){return{valid:!1,reason:`Failed to parse token: ${t.message}`}}return e.sig?{valid:!0}:{valid:!1,reason:"Invalid signature"}};var U=r=>{let e={iat:Date.now(),sub:r,permissions:{}};return H(e,process.env.ACCESS_TOKEN_SECRET||"SECRET")};var C=A(require("crypto"),1),x=class{algorithm;saltLength;constructor(e="sha256",t=64){this.algorithm=e,this.saltLength=t}verify(e,t){let{algorithm:s,salt:n}=this.parse(e);return this.hash(t,s,n)===e}encode(e){let t=C.default.randomBytes(this.saltLength).toString("base64");return this.hash(e,this.algorithm,t)}hash(e,t,s){let n=C.default.createHash(t);return n.update(e),n.update(s,"utf8"),`${t}:${s}:${n.digest("base64")}`}parse(e){let t=e.split(":");if(t.length!==3)throw new Error(`Invalid hash string. Expected 3 parts, got ${t.length}`);let s=t[0],n=t[1],o=t[2];return{algorithm:s,salt:n,digest:o}}},y=new x;var b=class{static init({host:e="localhost",port:t=3351,secure:s=!1}){this.emitter=new W.EventEmitter,this.queryHandler=new E,this.initializeCollections(),this.ensureRootUserExists(),this.createServer(e,t,s)}static initializeCollections(){this.auth.users=new l.Collection({autosync:!0,timestamps:!0,adapter:new l.FSAdapter(".internal","users")}),this.auth.accessTokens=new l.Collection({autosync:!0,timestamps:!0,adapter:new l.FSAdapter(".internal","accessTokens")})}static ensureRootUserExists(){this.auth.users.find({username:"root"}).length||this.auth.users.insert({username:"root",password:y.encode("root")})}static query(e){return this.queryHandler.query(e)}static createUser(e,t){if(this.auth.users.find({username:e})[0])throw new Error("User already exists");this.auth.users.insert({username:e,password:y.encode(t)})}static removeUser(e){if(!this.auth.users.find({username:e})[0])throw new Error("User does not exist");this.auth.users.remove({username:e})}static createServer(e,t,s=!1){this.duplex=new P.CommandServer({host:e,port:t,secure:s}),this.duplex.command(0,async(n,o)=>{if(this.emitter.emit("auth",{payload:n,connection:o}),!n.username||!n.password)return{error:"Invalid username or password"};let i=this.auth.users.find({username:n.username})[0];if(!i)return{error:"Invalid username or password"};if(!y.verify(i.password,n.password))return{error:"Invalid username or password"};let a=U(n.username);return this.auth.accessTokens.remove({username:n.username}),this.auth.accessTokens.insert({username:n.username,accessToken:a}),{accessToken:a}}),this.duplex.command(2,async(n,o)=>{this.emitter.emit("query",{payload:n,connection:o});let{accessToken:i}=n;return p(i).valid?this.queryHandler.query(n):{error:"Invalid access token"}}),this.duplex.command(3,async(n,o)=>{this.emitter.emit("createUser",{payload:n,connection:o});let{username:i,password:a,accessToken:g}=n;if(!i||!a)return{error:"Invalid username or password"};if(!p(g).valid)return{error:"Invalid access token"};try{return b.createUser(i,a),{success:!0}}catch(u){return{error:u.message}}}),this.duplex.command(4,async(n,o)=>{this.emitter.emit("removeUser",{payload:n,connection:o});let{username:i,password:a,accessToken:g}=n;if(!i||!a)return{error:"Invalid username or password"};if(!p(g).valid)return{error:"Invalid access token"};try{return b.removeUser(i),{success:!0}}catch(u){return{error:u.message}}})}},c=b;h(c,"queryHandler"),h(c,"duplex"),h(c,"auth",{}),h(c,"emitter");var I={autosync:!0,timestamps:!0},T=class{collections={};getCollection(e){return this.getOrCreateCollection(e)}getOrCreateCollection(e){if(!this.collections[e]){let t={...I,adapter:new l.FSAdapter(".data",e)};this.collections[e]={collection:new l.Collection(t),options:t}}return this.collections[e].collection}createCollectionWithOptions(e,t={}){if(this.collections[e])throw new Error(`Collection ${e} already exists`);let s={...I,...t,adapter:new l.FSAdapter(".data",e)};return this.collections[e]={collection:new l.Collection(s),options:s},this.collections[e].collection}},E=class{cm;constructor(){this.cm=new T}query(e){if(!e)throw new Error("A payload is required.");if(!e.collection)throw new Error("A query should include a collection property.");if(!e.operation)throw new Error("A query should include an operation property (find, insert, update, remove).");let t=this.cm.getOrCreateCollection(e.collection);if(!t)throw new Error(`The collection ${e.collection} does not exist.`);if(e.operation!=="drop"&&!e?.data?.query)throw new Error("This payload is missing a query.");let s=e?.data?.query||{},n=e?.data?.operations||{},o=e?.data?.options||{};switch(e.operation){case"drop":return t.drop();case"find":return t.find(s,o);case"insert":return t.insert(s);case"update":return t.update(s,n,o);case"remove":return t.remove(s,o);default:throw new Error(`Unsupported operation: "${e.operation}".`)}}};c.init({host:"0.0.0.0",port:3351,secure:!1});c.duplex.on("insecureConnection",r=>{console.log("insecureConnection from",r.remoteAddress)});c.duplex.on("secureConnection",r=>{console.log("secureConnection from",r.remoteAddress)});c.duplex.on("error",r=>{console.log("error:",r)});c.duplex.on("remoteClose",r=>{console.log("remoteClose:",r)});c.duplex.on("close",r=>{console.log("close:",r)});c.duplex.on("closed",r=>{console.log("closed:",r)});c.duplex.on("disconnect",r=>{console.log("disconnect:",r)});c.emitter.on("auth",({payload:r})=>{console.log("auth:",r)});c.emitter.on("query",({payload:r})=>{console.log("query:",r)});0&&(module.exports={ArcServer});
